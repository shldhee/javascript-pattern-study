# Chapter3 함수

## 1. 배경 지식

자바스크립트의 함수를 특별하게 만드는 두 가지 중요한 특징

1. ***함수는 일급(first-class) 객체다.***
1. ***함수는 유효범위(scope)를 제공한다.***

**1급객체란?**

* 1급함수는 함수의 인자가 될수 있어야 한다.
* 1급함수는 함수의 리턴이 될수 있어야 한다.
* 1급함수는 변수에 할당 될수 있어야 한다.

**함수는 다음과 같은 특징을 가지는 객체다.**

* 런타임, 즉 프로그램 실행 중에 동적으로 생성할 수 있다.
* 변수에 할당할 수 있고, 다른 변수에 참조를 복사할 수 있으며, 확장가능하고, 몇몇 특별한 경우를 제외하면 삭제 할 수 있다.
* 다른 함수의 인자로 전달할 수 있고, 다른 함수의 반환 값이 될 수 있다.
* 자기 자신의 프로퍼티와 메서드를 가질 수 있다.

``` js
var test_fn1 = function(){ console.log('first class function'); }; // 함수는 변수에 할당 될수있다.
console.log(test_fn1());

var test_fn2 = function(fn){ fn(); }; //함수 인자를 실행

test_fn2(function(){ console.log('나는 익명함수...');}); //함수는 함수의 인자가 될수 있다

var fn_outer = function(){
	console.log('fn_outer 함수 동작...');
return function(){
	console.log('리턴되는 함수가 동작...');
	};
};

var ret_fn = fn_outer();
ret_fn();    // fn_outer함수의 리턴된 함수가 실행된다. 즉 함수는 함수의 리턴이 될수있다.
ret_fn();
```

***자바스크립트에서 함수는 하나의 객체라고 생각하면 된다.***

다음 예제를 보자.

``` js
// 안티패턴
// 데모의 목적으로만 사용
var add = new Function('a, b', 'return a + b');
add(1, 2); // 3을 반환
```

이 코드는 add()는 생성자를 통해 만들었기 때문에 객체라는 사실이 명확하다. *그러나 Function() 생성자의 사용은 좋지 않다.* 코드가 문자열로 전달되고 따옴표를 이스케이프해야 하고 가독성이 좋지 않다.

**두 번째로 중요한 기능은 함수가 유효범위를 제공한다.**

자바스크립트에서는 중괄호({}) 지역 유효범위가 없고 단지 함수 유효범위가 있다.
어떤 변수이건 함수 내에서 `var`로 정의되면 지역 변수이고 함수 밖에서 참조할 수 없다.
중괄호가 지역 유효범위를 제공하지 않는다는 말은 변수를 `if문`, `for문`, `while문` 내에서 `var`로 정의해도, 이 변수가 `if`나 `for`, `while`문의 지역변수가 되지 않는다.

전역 변수를 최소화하는 것이 좋기 때문에 변수의 유효범위를 잘 관리하기 위해서 함수는 없어서는 안될 존재다.

### 용어정리

패턴에 대해 이야기할 때 합의된 정확한 이름을 사용하는 것은 코드자체만큼이나 중요하다.

#### 함수 표현식(function expression)

``` js
// 기명 함수 표현식
var add = function add(a, b) {
	return a +  b;
};

var add1 = function add2(a, b) {
	return a +  b;
};

add1(1,2); // var 뒤에껄로 함수 호출
```

이 코드는 `기명 함수 표현식(named function expression)`을 사용한 함수
이름을 생략한 함수 표현식을 `무명 함수 표현식(unnamed function expression)`이라고 한다.
간단하게 `함수 표현식(function expression)`이라고도 하고, `익명 함수(anonymouse function)`라느 말로도 널리 쓰인다.

``` js
// 함수 표현식 (또는 익명 함수)
var add = function (a, b) {
	return a + b;
};
```

* `기명 함수 표현식`에서 두 번째 `add`를 생략하고 `무명 함수 표현식`으로 끝내도, 함수의 정의나 뒤이은 함수의 호출에 영향을 미치지 않는다.
* 유일한 차이점은 함수 객체의 `name`프로퍼티가 빈 문자열이 된다는 것이다.
* `name` 프로퍼티는 ECMA 표준이 아니라 언어의 확장기능이지만 많은 실행 환경에서 사용된다.
* 두 번째 `add`를 그대로 유지한다면 `add.name` 프로퍼티는 문자열 "add"라는 값을 가지게 된다.
* `name`프로퍼티는 파이어버그와 같은 디버거를 사용할 때,
* 그리고 함수 안에서 자기 자신을 재귀적으로 호출할때 유용하다. 이런 용도로 쓸게 아니면 생략해도 된다.

#### 함수 선언문(function declaration)

``` js
function foo() {
	// 함수 본문
}
```

함수 표현식의 결과를 변수에 할당하지 않을 경우 기명 함수 표현식과 함수 선언문은 비슷해 보인다. 생성하는 문맥을 보지 않고서는 구분할 수 없다.
세미콜론이 붙는지 여부에 따라 그 둘의 문법적인 차이가 있다.
함수 선언문에는 세미콜론이 필요하지 않지만 함수표현식에는 필요하다.
**항상 세미콜론을 사용하자.**

### 선언문 vs 표현식: 이름과 호이스팅

함수 선언문과 함수 표현식 중 어떤 것을 사용해야 될까?
**함수 선언문을 사용할 수 없는 경우를 생각하면 쉽게 풀린다.**

``` js
// 함수 표현식을 callMe 함수의 인자로 전달한다.
callMe(function () {
	// 이 함수는 무명 함수(익명 함수) 표현식이다.
});

// 기명 함수 표현식을 callMe 함수의 인자로 전달한다.
callMe(function me() {
	// 이 함수는 "me"라는 기명 함수 표현식이다.
});

// 함수 표현식을 객체의 프로퍼티로 저장한다.
var myobject = {
	say: function () {
		// 이 함수는 함수 표현식이다.
	}
};
```

***함수 선언문은 전역 유효범위나 다른 함수의 본문 내부, 즉 '프로그램 코드'에만 쓸 수 있다.***
* 변수, 프로퍼티에 할당할 수 없다.(var 빼면 기명 함수 표현식과 같은데.......?)
* 함수 호출시 인자로 함수를 넘길 때도 사용할 수 없다.

``` js
// 전역 유효범위
function foo() {}
	function local() {
		// 지역 유효범위
		function bar() {}
			return bar;
	}
```

#### 함수의 name 프로퍼티

`name프로퍼티`는 표준이 아니다.
`함수 선언문`과 `기명 함수 표현식`을 사용하면 `name 프로퍼티`가 정의된다.
반면 `무명 함수 표현식`의 `name 프로퍼티`값은 경우에 따라 다르다.
IE는 `undefined` Chorme은 `변수값`

``` js
function foo() {} // 함수 선언문
var bar = function () {}; // 함수 표현식
var baz = function baz() {}; // 기명 함수 표현식

foo.name; // "foo"
bar.name; // X ""  O "bar"
baz.name; // "baz"
```

`name프로퍼티`는 파이어버그, 디버거에서 코드를 디버깅할 때 유용
함수 내에서 발생한 에러를 보여주어야 할 때, 디버거가 `name 프로퍼티`값을 확인하여 이름표로 사용
함수 내부에서 자신을 재귀적으로 호출할 떄도 사용하기도 한다.

***함수 선언문보다 함수 표현식을 선호나느 이유는, 함수 표현식을 사용하면 함수가 다른 객체들과 마찬가지로 객체의 일종이며 어떤 특별한 언어 구성요소가 아니라는 사실이 좀더 드러나기 떄문***

### 함수 호이스팅
